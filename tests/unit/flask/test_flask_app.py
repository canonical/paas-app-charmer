# Copyright 2024 Canonical Ltd.
# See LICENSE file for licensing details.

"""Flask charm unit tests for the flask_app module."""

# this is a unit test file
# pylint: disable=protected-access

import json
import typing
import unittest.mock

import pytest

from paas_app_charmer._gunicorn.webserver import WebserverConfig
from paas_app_charmer._gunicorn.workload_config import create_workload_config
from paas_app_charmer._gunicorn.wsgi_app import WsgiApp
from paas_app_charmer.app import map_integrations_to_env
from paas_app_charmer.charm_state import CharmState, IntegrationsState, S3Parameters


@pytest.mark.parametrize(
    "flask_config,app_config",
    [
        pytest.param({"env": "test"}, {}, id="env"),
        pytest.param({"permanent_session_lifetime": 1}, {}, id="permanent_session_lifetime"),
        pytest.param({"debug": True}, {}, id="debug"),
        pytest.param({"application_root": "/"}, {"application_root": "/foo"}, id="duplicate"),
    ],
)
def test_flask_env(flask_config: dict, app_config: dict, database_migration_mock):
    """
    arrange: create the Flask app object with a controlled charm state.
    act: none.
    assert: flask_environment generated by the Flask app object should be acceptable by Flask app.
    """
    charm_state = CharmState(
        framework="flask",
        secret_key="foobar",
        is_secret_storage_ready=True,
        framework_config=flask_config,
        app_config=app_config,
    )
    workload_config = create_workload_config(framework_name="flask", unit_name="flask/0")
    flask_app = WsgiApp(
        container=unittest.mock.MagicMock(),
        charm_state=charm_state,
        workload_config=workload_config,
        webserver=unittest.mock.MagicMock(),
        database_migration=database_migration_mock,
    )
    env = flask_app.gen_environment()
    assert env["FLASK_SECRET_KEY"] == "foobar"
    del env["FLASK_SECRET_KEY"]
    assert env == {
        f"FLASK_{k.upper()}": v if isinstance(v, str) else json.dumps(v)
        for k, v in flask_config.items()
    }


HTTP_PROXY_TEST_PARAMS = [
    pytest.param({}, {}, id="no_env"),
    pytest.param({"JUJU_CHARM_NO_PROXY": "127.0.0.1"}, {"no_proxy": "127.0.0.1"}, id="no_proxy"),
    pytest.param(
        {"JUJU_CHARM_HTTP_PROXY": "http://proxy.test"},
        {"http_proxy": "http://proxy.test"},
        id="http_proxy",
    ),
    pytest.param(
        {"JUJU_CHARM_HTTPS_PROXY": "http://proxy.test"},
        {"https_proxy": "http://proxy.test"},
        id="https_proxy",
    ),
    pytest.param(
        {
            "JUJU_CHARM_HTTP_PROXY": "http://proxy.test",
            "JUJU_CHARM_HTTPS_PROXY": "http://proxy.test",
        },
        {"http_proxy": "http://proxy.test", "https_proxy": "http://proxy.test"},
        id="http_https_proxy",
    ),
]


@pytest.mark.parametrize(
    "set_env, expected",
    HTTP_PROXY_TEST_PARAMS,
)
def test_http_proxy(
    set_env: typing.Dict[str, str],
    expected: typing.Dict[str, str],
    monkeypatch,
    database_migration_mock,
):
    """
    arrange: set juju charm http proxy related environment variables.
    act: generate a flask environment.
    assert: flask_environment generated should contain proper proxy environment variables.
    """
    for set_env_name, set_env_value in set_env.items():
        monkeypatch.setenv(set_env_name, set_env_value)
    charm_state = CharmState(
        framework="flask",
        secret_key="foobar",
        is_secret_storage_ready=True,
    )
    workload_config = create_workload_config(framework_name="flask", unit_name="flask/0")
    flask_app = WsgiApp(
        container=unittest.mock.MagicMock(),
        charm_state=charm_state,
        workload_config=workload_config,
        webserver=unittest.mock.MagicMock(),
        database_migration=database_migration_mock,
    )
    env = flask_app.gen_environment()
    expected_env: typing.Dict[str, typing.Optional[str]] = {
        "http_proxy": None,
        "https_proxy": None,
        "no_proxy": None,
    }
    expected_env.update(expected)
    for env_name, env_value in expected_env.items():
        assert env.get(env_name) == env.get(env_name.upper()) == env_value


@pytest.mark.parametrize(
    "integrations, expected_vars",
    [
        pytest.param(
            None,
            {},
            id="integrations is None",
        ),
        pytest.param(
            IntegrationsState(redis_uri="http://redisuri"),
            {
                "REDIS_DB_CONNECT_STRING": "http://redisuri",
            },
            id="integrations exists",
        ),
    ],
)
def test_integrations_env(
    monkeypatch,
    database_migration_mock,
    integrations,
    expected_vars,
):
    """
    arrange: prepare charmstate with integrations state.
    act: generate a flask environment.
    assert: flask_environment generated should contain the expected env vars.
    """
    charm_state = CharmState(
        framework="flask",
        secret_key="foobar",
        is_secret_storage_ready=True,
        integrations=integrations,
    )
    workload_config = create_workload_config(framework_name="flask", unit_name="flask/0")
    flask_app = WsgiApp(
        container=unittest.mock.MagicMock(),
        charm_state=charm_state,
        workload_config=workload_config,
        webserver=unittest.mock.MagicMock(),
        database_migration=database_migration_mock,
    )
    env = flask_app.gen_environment()
    for expected_var_name, expected_env_value in expected_vars.items():
        assert expected_var_name in env
        assert env[expected_var_name] == expected_env_value


@pytest.mark.parametrize(
    "integrations, expected_env",
    [
        pytest.param(
            IntegrationsState(),
            {},
            id="no new env vars",
        ),
        pytest.param(
            IntegrationsState(redis_uri="http://redisuri"),
            {
                "REDIS_DB_CONNECT_STRING": "http://redisuri",
                "REDIS_DB_FRAGMENT": "",
                "REDIS_DB_HOSTNAME": "redisuri",
                "REDIS_DB_NETLOC": "redisuri",
                "REDIS_DB_PARAMS": "",
                "REDIS_DB_PATH": "",
                "REDIS_DB_QUERY": "",
                "REDIS_DB_SCHEME": "http",
            },
            id="With Redis uri",
        ),
        pytest.param(
            IntegrationsState(
                databases_uris={
                    "postgresql": "postgresql://test-username:test-password@test-postgresql:5432/test-database?connect_timeout=10",
                    "mysql": "mysql://test-username:test-password@test-mysql:3306/flask-app",
                    "mongodb": None,
                    "futuredb": "futuredb://foobar/",
                },
            ),
            {
                "POSTGRESQL_DB_CONNECT_STRING": "postgresql://test-username:test-password@test-postgresql:5432/test-database?connect_timeout=10",
                "POSTGRESQL_DB_FRAGMENT": "",
                "POSTGRESQL_DB_HOSTNAME": "test-postgresql",
                "POSTGRESQL_DB_NAME": "test-database",
                "POSTGRESQL_DB_NETLOC": "test-username:test-password@test-postgresql:5432",
                "POSTGRESQL_DB_PARAMS": "",
                "POSTGRESQL_DB_PASSWORD": "test-password",
                "POSTGRESQL_DB_PATH": "/test-database",
                "POSTGRESQL_DB_PORT": "5432",
                "POSTGRESQL_DB_QUERY": "connect_timeout=10",
                "POSTGRESQL_DB_SCHEME": "postgresql",
                "POSTGRESQL_DB_USERNAME": "test-username",
                "MYSQL_DB_CONNECT_STRING": "mysql://test-username:test-password@test-mysql:3306/flask-app",
                "MYSQL_DB_FRAGMENT": "",
                "MYSQL_DB_HOSTNAME": "test-mysql",
                "MYSQL_DB_NAME": "flask-app",
                "MYSQL_DB_NETLOC": "test-username:test-password@test-mysql:3306",
                "MYSQL_DB_PARAMS": "",
                "MYSQL_DB_PASSWORD": "test-password",
                "MYSQL_DB_PATH": "/flask-app",
                "MYSQL_DB_PORT": "3306",
                "MYSQL_DB_QUERY": "",
                "MYSQL_DB_SCHEME": "mysql",
                "MYSQL_DB_USERNAME": "test-username",
                "FUTUREDB_DB_CONNECT_STRING": "futuredb://foobar/",
                "FUTUREDB_DB_FRAGMENT": "",
                "FUTUREDB_DB_HOSTNAME": "foobar",
                "FUTUREDB_DB_NAME": "",
                "FUTUREDB_DB_NETLOC": "foobar",
                "FUTUREDB_DB_PARAMS": "",
                "FUTUREDB_DB_PATH": "/",
                "FUTUREDB_DB_QUERY": "",
                "FUTUREDB_DB_SCHEME": "futuredb",
            },
            id="With several databases, one of them None.",
        ),
        pytest.param(
            IntegrationsState(
                s3_parameters=S3Parameters.model_construct(
                    access_key="access_key",
                    secret_key="secret_key",
                    bucket="bucket",
                ),
            ),
            {
                "S3_ACCESS_KEY": "access_key",
                "S3_SECRET_KEY": "secret_key",
                "S3_BUCKET": "bucket",
            },
            id="With minimal variables in S3 Integration.",
        ),
        pytest.param(
            IntegrationsState(
                s3_parameters=S3Parameters.model_construct(
                    access_key="access_key",
                    secret_key="secret_key",
                    region="region",
                    storage_class="GLACIER",
                    bucket="bucket",
                    endpoint="https://s3.example.com",
                    path="/path/subpath/",
                    s3_api_version="s3v4",
                    uri_style="host",
                    tls_ca_chain=(
                        ca_chain := [
                            "-----BEGIN CERTIFICATE-----\nTHE FIRST LONG CERTIFICATE\n-----END CERTIFICATE-----",
                            "-----BEGIN CERTIFICATE-----\nTHE SECOND LONG CERTIFICATE\n-----END CERTIFICATE-----",
                        ]
                    ),
                    attributes=(
                        attributes := [
                            "header1:value1",
                            "header2:value2",
                        ]
                    ),
                ),
            ),
            {
                "S3_ACCESS_KEY": "access_key",
                "S3_SECRET_KEY": "secret_key",
                "S3_API_VERSION": "s3v4",
                "S3_BUCKET": "bucket",
                "S3_ENDPOINT": "https://s3.example.com",
                "S3_PATH": "/path/subpath/",
                "S3_REGION": "region",
                "S3_STORAGE_CLASS": "GLACIER",
                "S3_ATTRIBUTES": json.dumps(attributes),
                "S3_TLS_CA_CHAIN": json.dumps(ca_chain),
            },
            id="With all variables in S3 Integration.",
        ),
    ],
)
def test_map_integrations_to_env(
    integrations,
    expected_env,
):
    """
    arrange: prepare integrations state.
    act: call to generate mappings to env variables.
    assert: the variables generated should be the expected ones.
    """
    env = map_integrations_to_env(integrations)
    assert env == expected_env
