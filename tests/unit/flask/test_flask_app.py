# Copyright 2024 Canonical Ltd.
# See LICENSE file for licensing details.

"""Flask charm unit tests for the flask_app module."""

# this is a unit test file
# pylint: disable=protected-access

import json
import typing
import unittest.mock

import pytest

from paas_app_charmer._gunicorn.charm_state import CharmState, IntegrationsState
from paas_app_charmer._gunicorn.webserver import WebserverConfig
from paas_app_charmer._gunicorn.workload_state import WorkloadState
from paas_app_charmer._gunicorn.wsgi_app import WsgiApp, map_integrations_to_env


@pytest.mark.parametrize(
    "flask_config,app_config",
    [
        pytest.param({"env": "test"}, {}, id="env"),
        pytest.param({"permanent_session_lifetime": 1}, {}, id="permanent_session_lifetime"),
        pytest.param({"debug": True}, {}, id="debug"),
        pytest.param({"application_root": "/"}, {"application_root": "/foo"}, id="duplicate"),
    ],
)
def test_flask_env(flask_config: dict, app_config: dict, database_migration_mock):
    """
    arrange: create the Flask app object with a controlled charm state.
    act: none.
    assert: flask_environment generated by the Flask app object should be acceptable by Flask app.
    """
    charm_state = CharmState(
        framework="flask",
        secret_key="foobar",
        is_secret_storage_ready=True,
        wsgi_config=flask_config,
        app_config=app_config,
    )
    workload_state = WorkloadState(
        framework="flask",
    )
    flask_app = WsgiApp(
        container=unittest.mock.MagicMock(),
        charm_state=charm_state,
        workload_state=workload_state,
        webserver=unittest.mock.MagicMock(),
        database_migration=database_migration_mock,
    )
    env = flask_app.gen_environment()
    assert env["FLASK_SECRET_KEY"] == "foobar"
    del env["FLASK_SECRET_KEY"]
    assert env == {
        f"FLASK_{k.upper()}": v if isinstance(v, str) else json.dumps(v)
        for k, v in flask_config.items()
    }


HTTP_PROXY_TEST_PARAMS = [
    pytest.param({}, {}, id="no_env"),
    pytest.param({"JUJU_CHARM_NO_PROXY": "127.0.0.1"}, {"no_proxy": "127.0.0.1"}, id="no_proxy"),
    pytest.param(
        {"JUJU_CHARM_HTTP_PROXY": "http://proxy.test"},
        {"http_proxy": "http://proxy.test"},
        id="http_proxy",
    ),
    pytest.param(
        {"JUJU_CHARM_HTTPS_PROXY": "http://proxy.test"},
        {"https_proxy": "http://proxy.test"},
        id="https_proxy",
    ),
    pytest.param(
        {
            "JUJU_CHARM_HTTP_PROXY": "http://proxy.test",
            "JUJU_CHARM_HTTPS_PROXY": "http://proxy.test",
        },
        {"http_proxy": "http://proxy.test", "https_proxy": "http://proxy.test"},
        id="http_https_proxy",
    ),
]


@pytest.mark.parametrize(
    "set_env, expected",
    HTTP_PROXY_TEST_PARAMS,
)
def test_http_proxy(
    set_env: typing.Dict[str, str],
    expected: typing.Dict[str, str],
    monkeypatch,
    database_migration_mock,
):
    """
    arrange: set juju charm http proxy related environment variables.
    act: generate a flask environment.
    assert: flask_environment generated should contain proper proxy environment variables.
    """
    for set_env_name, set_env_value in set_env.items():
        monkeypatch.setenv(set_env_name, set_env_value)
    charm_state = CharmState(
        framework="flask",
        secret_key="foobar",
        is_secret_storage_ready=True,
    )
    workload_state = WorkloadState(
        framework="flask",
    )
    flask_app = WsgiApp(
        container=unittest.mock.MagicMock(),
        charm_state=charm_state,
        workload_state=workload_state,
        webserver=unittest.mock.MagicMock(),
        database_migration=database_migration_mock,
    )
    env = flask_app.gen_environment()
    expected_env: typing.Dict[str, typing.Optional[str]] = {
        "http_proxy": None,
        "https_proxy": None,
        "no_proxy": None,
    }
    expected_env.update(expected)
    for env_name, env_value in expected_env.items():
        assert env.get(env_name) == env.get(env_name.upper()) == env_value


@pytest.mark.parametrize(
    "integrations, expected_vars",
    [
        pytest.param(
            None,
            {},
            id="integrations is None",
        ),
        pytest.param(
            IntegrationsState(redis_uri="http://redisuri"),
            {
                "REDIS_DB_CONNECT_STRING": "http://redisuri",
            },
            id="integrations exists",
        ),
    ],
)
def test_integrations_env(
    monkeypatch,
    database_migration_mock,
    integrations,
    expected_vars,
):
    """
    arrange: prepare charmstate with integrations state.
    act: generate a flask environment.
    assert: flask_environment generated should contain the expected env vars.
    """
    charm_state = CharmState(
        framework="flask",
        secret_key="foobar",
        is_secret_storage_ready=True,
        integrations=integrations,
    )
    workload_state = WorkloadState(
        framework="flask",
    )
    flask_app = WsgiApp(
        container=unittest.mock.MagicMock(),
        charm_state=charm_state,
        workload_state=workload_state,
        webserver=unittest.mock.MagicMock(),
        database_migration=database_migration_mock,
    )
    env = flask_app.gen_environment()
    for expected_var_name, expected_env_value in expected_vars.items():
        assert expected_var_name in env
        assert env[expected_var_name] == expected_env_value


@pytest.mark.parametrize(
    "integrations, expected_env",
    [
        pytest.param(
            IntegrationsState(),
            {},
            id="no new env vars",
        ),
        pytest.param(
            IntegrationsState(redis_uri="http://redisuri"),
            {
                "REDIS_DB_CONNECT_STRING": "http://redisuri",
            },
            id="With Redis uri",
        ),
        pytest.param(
            IntegrationsState(
                databases_uris={
                    "postgresql": "postgresql://test-username:test-password@test-postgresql:5432/test-database",
                    "mysql": "mysql://test-username:test-password@test-mysql:3306/flask-app",
                    "mongodb": None,
                    "futuredb": "futuredb://foobar/",
                },
            ),
            {
                "POSTGRESQL_DB_CONNECT_STRING": "postgresql://test-username:test-password@test-postgresql:5432/test-database",
                "MYSQL_DB_CONNECT_STRING": "mysql://test-username:test-password@test-mysql:3306/flask-app",
                "FUTUREDB_DB_CONNECT_STRING": "futuredb://foobar/",
            },
            id="With several databases, one of them None.",
        ),
    ],
)
def test_map_integrations_to_env(
    integrations,
    expected_env,
):
    """
    arrange: prepare integrations state.
    act: call to generate mappings to env variables.
    assert: the variables generated should be the expected ones.
    """
    env = map_integrations_to_env(integrations)
    assert env == expected_env
